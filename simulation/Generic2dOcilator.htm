<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Generic2dOscillator (Phase Plane + Time Series)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --ink:#e7ecff; --muted:#9fb2ff;
      --accent:#7aa2ff; --grid:#1d2748; --axis:#7e8cc2;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans;
      color:var(--ink);
      background:radial-gradient(1200px 600px at 20% -10%, #1a2444 0%, #0b1020 40%, #090e1d 100%);
    }
    .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
    .card{
      background:var(--panel);
      border-radius:14px;border:1px solid #1d2443;
      box-shadow:0 10px 30px rgba(0,0,0,.35)
    }
    header.page-title{display:flex;align-items:center;gap:10px;justify-content:center;margin:12px 0}
    header.page-title h1{font-size:18px;margin:0;color:var(--muted);letter-spacing:.2px}

    .stage{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-bottom:10px}
    .canvas-card{position:relative;}
    .canvas-card header{
      position:absolute;left:10px;top:10px;
      background:rgba(12,16,35,.6);backdrop-filter:blur(6px);
      border:1px solid #2a325b;border-radius:10px;padding:6px 10px
    }
    .canvas-card header h2{margin:0;font-size:12px;color:var(--muted);letter-spacing:.3px}
    canvas{display:block;width:100%;height:520px;border-radius:14px;background:#0a1026}
    .legend{
      position:absolute;right:12px;bottom:12px;background:rgba(12,16,35,.6);
      border:1px solid #2a325b;border-radius:10px;
      padding:8px 10px;color:var(--ink);font-size:12px
    }
    .legend .item{display:flex;align-items:center;gap:8px;margin:4px 0}
    .swatch{width:30px;height:0;border-top:3px solid currentColor}
    .swatch.dashed{border-top-style:dashed}

    .controls{
      display:flex;
      flex-wrap:nowrap;
      align-items:flex-end;
      gap:8px;
      padding:10px 12px;
      margin-top:10px;
      overflow-x:auto;
      scrollbar-width:thin;
    }
    .row{
      display:flex;gap:8px;align-items:center;
      flex:0 0 auto;
      padding-right:8px;
      border-right:1px solid #24305a;
      margin-right:6px;
    }
    .btn{
      cursor:pointer;border:none;border-radius:12px;
      padding:8px 12px;font-weight:600;
      color:#0a0f20;background:var(--accent);
      flex:0 0 auto;
      white-space:nowrap;
    }
    .btn.secondary{background:#24305a;color:var(--ink);border:1px solid #33407a}

    .spacer{flex:0 0 10px; height:1px;}

    .control{
      display:flex;flex-direction:column;gap:2px;
      flex:0 0 auto;
      width:78px;
    }
    .control.wide{width:120px}
    .control label{
      font-size:10px;color:var(--muted);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .control input{
      background:#0e1530;color:var(--ink);
      border:1px solid #28335f;border-radius:10px;
      padding:4px 6px;
      outline:none;
      width:100%;
      font-size:12px;
    }
    .control input:focus{border-color:#3a56a8;box-shadow:0 0 0 3px rgba(122,162,255,.2)}
    .checkline{
      display:flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:12px;
      border:1px solid #28335f; background:#0e1530;
      color:var(--muted); font-size:12px;
      white-space:nowrap;
    }
    .checkline input{ transform: translateY(1px); }

    .footer{color:#9fb2ff78;margin-top:10px;font-size:12px;text-align:center}

    @media (max-width:980px){
      .stage{grid-template-columns:1fr}
      canvas{height:440px}
    }
  </style>
</head>
<body>
  <div class="wrap">

    <div class="stage">
      <div class="card canvas-card">
        <header><h2>Phase plane</h2></header>
        <canvas id="phase"></canvas>
        <div class="legend">
          <div class="item"><span class="swatch" style="color:#e7ecff"></span> dV/dt = 0</div>
          <div class="item"><span class="swatch dashed" style="color:#e7ecff"></span> dW/dt = 0</div>
        </div>
      </div>
      <div class="card canvas-card">
        <header><h2>Time series (up to 3 trajectories)</h2></header>
        <canvas id="time"></canvas>
      </div>
    </div>

    <header class="page-title">
      <h1>Interactive Generic2dOscillator • Phase plane + time series</h1>
    </header>

    <div class="card controls" id="controls">
      <div class="row">
        <button class="btn" id="runBtn">Play</button>
        <button class="btn secondary" id="pauseBtn" title="Pause/Resume">Pause</button>
        <button class="btn secondary" id="resetBtn" title="Reset to defaults">Reset</button>
      </div>

      <div class="spacer"></div>

      <div class="control"><label for="N">N</label><input id="N" type="number" min="1" max="2000" step="1" value="3"></div>

      <!-- Inputs / time-scales -->
      <div class="control"><label for="I">I</label><input id="I" type="number" step="0.01" value="0.55"></div>
      <div class="control"><label for="gamma">gamma</label><input id="gamma" type="number" step="0.01" value="1.0"></div>
      <div class="control"><label for="tau">tau</label><input id="tau" type="number" step="0.1" value="6.0"></div>
      <div class="control"><label for="d">d</label><input id="d" type="number" step="0.001" value="0.035"></div>

      <!-- V polynomial -->
      <div class="control"><label for="f">f</label><input id="f" type="number" step="0.01" value="1.2"></div>
      <div class="control"><label for="e">e</label><input id="e" type="number" step="0.01" value="2.5"></div>
      <div class="control"><label for="g">g</label><input id="g" type="number" step="0.01" value="-0.2"></div>

      <!-- Coupling V<->W -->
      <div class="control"><label for="alpha">alpha</label><input id="alpha" type="number" step="0.01" value="1.0"></div>
      <div class="control"><label for="beta">beta</label><input id="beta" type="number" step="0.01" value="1.4"></div>

      <!-- W equation params -->
      <div class="control"><label for="a">a</label><input id="a" type="number" step="0.01" value="-1.2"></div>
      <div class="control"><label for="b">b</label><input id="b" type="number" step="0.01" value="-5.5"></div>
      <div class="control"><label for="c">c</label><input id="c" type="number" step="0.01" value="0.0"></div>

      <!-- Simulation / animation -->
      <div class="control"><label for="dt">dt</label><input id="dt" type="number" step="0.001" value="0.03"></div>
      <div class="control"><label for="steps">steps</label><input id="steps" type="number" min="10" max="20000" step="10" value="6000"></div>

      <!-- fps can actually go higher -->
      <div class="control"><label for="fps">fps</label><input id="fps" type="number" min="1" max="300" step="1" value="120"></div>

      <!-- Slower default: speed=2 -->
      <div class="control"><label for="speed">speed</label><input id="speed" type="number" min="1" max="200" step="1" value="2"></div>

      <div class="control"><label for="trail">trail</label><input id="trail" type="number" min="2" max="2000" step="1" value="220"></div>
      <div class="control"><label for="seed">seed</label><input id="seed" type="number" step="1" value="3"></div>

      <div class="row">
        <div class="checkline" title="Auto-fit the phase plane bounds so the nullclines + trajectory are fully visible">
          <input id="autoBounds" type="checkbox" checked />
          <label for="autoBounds">Auto phase bounds</label>
        </div>
        <div class="control"><label for="vmin">Vmin</label><input id="vmin" type="number" step="0.1" value="-2.2"></div>
        <div class="control"><label for="vmax">Vmax</label><input id="vmax" type="number" step="0.1" value="2.2"></div>
        <div class="control"><label for="wmin">Wmin</label><input id="wmin" type="number" step="0.1" value="-2.0"></div>
        <div class="control"><label for="wmax">Wmax</label><input id="wmax" type="number" step="0.1" value="2.0"></div>
      </div>
    </div>

    <div class="footer">
      Notation:
      <span style="color:var(--muted)">
        dV/dt = d·tau·(−fV³ + eV² + gV + αW + γI),
        dW/dt = (d/tau)·(cV² + bV − βW + a)
      </span>
    </div>
  </div>

  <script>
  // ------------------------- Defaults -------------------------
  const DEFAULTS = Object.freeze({
    N:3,
    // spike-ish preset
    I:0.55, gamma:1.0, tau:6.0, d:0.035,
    f:1.2, e:2.5, g:-0.2,
    alpha:1.0, beta:1.4,
    a:-1.2, b:-5.5, c:0.0,
    // sim
    dt:0.03, steps:6000, fps:120, speed:2, trail:220, seed:3,
    // phase bounds
    vmin:-2.2, vmax:2.2, wmin:-2.0, wmax:2.0,
    autoBounds:true
  });

  function $(id){return document.getElementById(id)}
  function clamp(x,min,max){return Math.max(min, Math.min(max, x))}
  function isFiniteNum(x){ return Number.isFinite(x) && !Number.isNaN(x); }

  function makeRNG(seed){ let s=(seed>>>0)||1; return ()=>{ s=(1664525*s+1013904223)>>>0; return s/0x100000000; }; }
  function randUniform(rng,a,b){ return a+(b-a)*rng(); }
  function makeColors(n){ const c=[]; for(let i=0;i<n;i++){ const h=(360*i/Math.max(1,n))|0; c.push(`hsl(${h} 90% 65%)`); } return c; }

  function makeTransform(xmin,xmax,ymin,ymax,width,height,pad=42){
    if(!(xmax>xmin)) { xmax = xmin + 1; }
    if(!(ymax>ymin)) { ymax = ymin + 1; }
    const sx=(width-2*pad)/(xmax-xmin), sy=(height-2*pad)/(ymax-ymin);
    return {
      xmin,xmax,ymin,ymax,
      toX: x=> pad + (x-xmin)*sx,
      toY: y=> height - pad - (y-ymin)*sy,
      pad, sx, sy, width, height
    };
  }

  function drawAxes(ctx, tf, {
    xTicks=6, yTicks=6,
    colorAxis='#7e8cc2', colorGrid='#1d2748',
    xLabel='', yLabel='', showGrid=false
  } = {}){
    const {pad, width: w, height: h} = tf;
    ctx.save();

    if(showGrid){
      ctx.strokeStyle=colorGrid; ctx.lineWidth=1; ctx.beginPath();
      for(let i=0;i<=xTicks;i++){ const x=pad+i*(w-2*pad)/xTicks; ctx.moveTo(x,pad); ctx.lineTo(x,h-pad); }
      for(let j=0;j<=yTicks;j++){ const y=pad+j*(h-2*pad)/yTicks; ctx.moveTo(pad,y); ctx.lineTo(w-pad,y); }
      ctx.stroke();
    }

    ctx.strokeStyle=colorAxis; ctx.lineWidth=1.4;
    ctx.beginPath(); ctx.rect(pad,pad,w-2*pad,h-2*pad); ctx.stroke();

    ctx.fillStyle=colorAxis;
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial';
    ctx.textAlign='center';
    ctx.fillText(xLabel, w/2, h - pad + 26);
    ctx.save();
    ctx.translate(pad - 26, h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign='center';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    ctx.restore();
  }

  // Model
  function g2d(V, W, P){
    const dV = P.d * P.tau * ( -P.f*V*V*V + P.e*V*V + P.g*V + P.alpha*W + P.gamma*P.I );
    const dW = (P.d / P.tau) * ( P.c*V*V + P.b*V - P.beta*W + P.a );
    return [dV, dW];
  }

  function rk4(V, W, dt, P){
    const k1 = g2d(V, W, P);
    const k2 = g2d(V + 0.5*dt*k1[0], W + 0.5*dt*k1[1], P);
    const k3 = g2d(V + 0.5*dt*k2[0], W + 0.5*dt*k2[1], P);
    const k4 = g2d(V + dt*k3[0],     W + dt*k3[1],     P);
    return [
      V + (dt/6)*(k1[0] + 2*k2[0] + 2*k3[0] + k4[0]),
      W + (dt/6)*(k1[1] + 2*k2[1] + 2*k3[1] + k4[1]),
    ];
  }

  function W_dV0(P, V){
    if(Math.abs(P.alpha) < 1e-12) return NaN;
    return (P.f*V*V*V - P.e*V*V - P.g*V - P.gamma*P.I) / P.alpha;
  }
  function W_dW0(P, V){
    if(Math.abs(P.beta) < 1e-12) return NaN;
    return (P.c*V*V + P.b*V + P.a) / P.beta;
  }

  function autoFitPhaseBounds(P, data){
    const scanVmin = isFiniteNum(P.vmin) ? P.vmin : -2.2;
    const scanVmax = isFiniteNum(P.vmax) ? P.vmax :  2.2;
    const vmin = Math.min(scanVmin, scanVmax);
    const vmax = Math.max(scanVmin, scanVmax);

    let wMinNC = +Infinity, wMaxNC = -Infinity;
    const samples = 1200;
    for(let i=0;i<=samples;i++){
      const V = vmin + i*(vmax - vmin)/samples;
      const w1 = W_dV0(P, V);
      const w2 = W_dW0(P, V);
      if(isFiniteNum(w1)){ wMinNC = Math.min(wMinNC, w1); wMaxNC = Math.max(wMaxNC, w1); }
      if(isFiniteNum(w2)){ wMinNC = Math.min(wMinNC, w2); wMaxNC = Math.max(wMaxNC, w2); }
    }
    if(!isFiniteNum(wMinNC) || !isFiniteNum(wMaxNC) || wMinNC === wMaxNC){
      wMinNC = -2; wMaxNC = 2;
    }

    let vMinTr=+Infinity, vMaxTr=-Infinity, wMinTr=+Infinity, wMaxTr=-Infinity;
    if(data){
      for(let t=0;t<data.V.length;t++){
        const Vrow = data.V[t], Wrow = data.W[t];
        for(let i=0;i<Vrow.length;i++){
          const vv = Vrow[i], ww = Wrow[i];
          if(isFiniteNum(vv)){ vMinTr = Math.min(vMinTr, vv); vMaxTr = Math.max(vMaxTr, vv); }
          if(isFiniteNum(ww)){ wMinTr = Math.min(wMinTr, ww); wMaxTr = Math.max(wMaxTr, ww); }
        }
      }
    }
    if(!isFiniteNum(vMinTr) || !isFiniteNum(vMaxTr)){ vMinTr = vmin; vMaxTr = vmax; }
    if(!isFiniteNum(wMinTr) || !isFiniteNum(wMaxTr)){ wMinTr = wMinNC; wMaxTr = wMaxNC; }

    let Vmin = Math.min(vmin, vMinTr);
    let Vmax = Math.max(vmax, vMaxTr);
    let Wmin = Math.min(wMinNC, wMinTr);
    let Wmax = Math.max(wMaxNC, wMaxTr);

    const vPad = 0.08*(Vmax - Vmin || 1);
    const wPad = 0.12*(Wmax - Wmin || 1);
    Vmin -= vPad; Vmax += vPad;
    Wmin -= wPad; Wmax += wPad;

    if(!(Vmax>Vmin)) { Vmax = Vmin + 1; }
    if(!(Wmax>Wmin)) { Wmax = Wmin + 1; }

    return {Vmin, Vmax, Wmin, Wmax};
  }

  function simulate(P){
    const rng = makeRNG(P.seed|0);
    const V = Array.from({length:P.steps}, ()=>new Float64Array(P.N));
    const W = Array.from({length:P.steps}, ()=>new Float64Array(P.N));

    for(let i=0;i<P.N;i++){
      V[0][i]=randUniform(rng,P.vmin,P.vmax);
      W[0][i]=randUniform(rng,P.wmin,P.wmax);
    }

    for(let t=1;t<P.steps;t++){
      const pv=V[t-1], pw=W[t-1], cv=V[t], cw=W[t];
      for(let i=0;i<P.N;i++){
        const r = rk4(pv[i], pw[i], P.dt, P);
        cv[i]=r[0]; cw[i]=r[1];
      }
    }

    const tAxis=new Float64Array(P.steps);
    for(let t=0;t<P.steps;t++) tAxis[t]=t*P.dt;

    let yMin=+Infinity,yMax=-Infinity;
    for(let t=0;t<P.steps;t++){
      for(let i=0;i<P.N;i++){
        const vv=V[t][i], ww=W[t][i];
        if(isFiniteNum(vv)){ yMin=Math.min(yMin,vv); yMax=Math.max(yMax,vv); }
        if(isFiniteNum(ww)){ yMin=Math.min(yMin,ww); yMax=Math.max(yMax,ww); }
      }
    }
    if(!isFiniteNum(yMin)||!isFiniteNum(yMax)||yMin===yMax){ yMin=-2; yMax=2; }
    const pad=0.05*(yMax-yMin||1); yMin-=pad; yMax+=pad;

    return {V,W,tAxis,yMin,yMax};
  }

  const phaseCanvas=$('phase'), timeCanvas=$('time');
  const pctx=phaseCanvas.getContext('2d'), tctx=timeCanvas.getContext('2d');

  function resizeCanvases(){
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    for(const c of [phaseCanvas,timeCanvas]){
      const rect=c.getBoundingClientRect();
      c.width=Math.round(rect.width*dpr);
      c.height=Math.round(rect.height*dpr);
      const ctx=c.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
  }
  function cssSize(c){ const r=c.getBoundingClientRect(); return {w:r.width, h:r.height}; }

  function drawPhaseStatic(P, tf){
    const ctx=pctx;
    ctx.clearRect(0,0,tf.width,tf.height);
    drawAxes(ctx, tf, {xTicks:6,yTicks:6, xLabel:'V', yLabel:'W', showGrid:false});

    const nx=24, ny=24;
    ctx.save();
    ctx.strokeStyle='#6f7fb6';
    ctx.globalAlpha=.26;
    for(let i=0;i<=nx;i++){
      const Vv=tf.xmin + i*(tf.xmax-tf.xmin)/nx;
      for(let j=0;j<=ny;j++){
        const Ww=tf.ymin + j*(tf.ymax-tf.ymin)/ny;
        let [dV, dW] = g2d(Vv, Ww, P);
        const sp=Math.hypot(dV,dW)||1e-6;
        dV/=sp; dW/=sp;

        const x=tf.toX(Vv), y=tf.toY(Ww);
        const scale=16;
        const x2=x + dV*scale;
        const y2=y - dW*scale;

        ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();

        const ah=4, ang=Math.atan2(y-y2, x2-x);
        ctx.beginPath(); ctx.moveTo(x2,y2);
        ctx.lineTo(x2-ah*Math.cos(ang-0.5), y2-ah*Math.sin(ang-0.5));
        ctx.lineTo(x2-ah*Math.cos(ang+0.5), y2-ah*Math.sin(ang+0.5));
        ctx.closePath(); ctx.fillStyle='#6f7fb6'; ctx.fill();
      }
    }
    ctx.restore();

    const samples=900;
    const dvPath=[], dwPath=[];
    for(let i=0;i<=samples;i++){
      const Vv=tf.xmin + i*(tf.xmax-tf.xmin)/samples;
      dvPath.push([tf.toX(Vv), tf.toY(W_dV0(P, Vv))]);
      dwPath.push([tf.toX(Vv), tf.toY(W_dW0(P, Vv))]);
    }

    ctx.save();
    ctx.strokeStyle='#e7ecff';
    ctx.lineWidth=1.6;
    ctx.beginPath();
    let started=false;
    for(let i=0;i<dvPath.length;i++){
      const [x,y]=dvPath[i];
      if(!isFiniteNum(y)) { started=false; continue; }
      if(!started){ ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.strokeStyle='#e7ecff';
    ctx.setLineDash([8,7]);
    ctx.lineWidth=1.6;
    ctx.beginPath();
    started=false;
    for(let i=0;i<dwPath.length;i++){
      const [x,y]=dwPath[i];
      if(!isFiniteNum(y)) { started=false; continue; }
      if(!started){ ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawPhaseDynamic(P, tf, colors, data, frame){
    drawPhaseStatic(P, tf);
    const ctx=pctx;
    for(let i=0;i<P.N;i++){
      const color=colors[i];
      const t0=Math.max(0, frame-P.trail);
      const L=frame-t0;

      if(L>=1){
        for(let k=t0;k<frame;k++){
          const j=k-t0;
          const frac=L>1? j/(L-1) : 1;
          const alpha=0.15+0.8*Math.pow(frac,1.5);
          const lw=0.4+1.0*Math.pow(frac,1.5);
          const x1=tf.toX(data.V[k][i]), y1=tf.toY(data.W[k][i]);
          const x2=tf.toX(data.V[k+1][i]), y2=tf.toY(data.W[k+1][i]);
          ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
          ctx.lineWidth=lw; ctx.strokeStyle=color; ctx.globalAlpha=alpha; ctx.stroke();
        }
        ctx.globalAlpha=1;
      }

      const xh=tf.toX(data.V[frame][i]), yh=tf.toY(data.W[frame][i]);
      ctx.beginPath(); ctx.arc(xh,yh,3.2,0,Math.PI*2);
      ctx.fillStyle=color; ctx.fill();
      ctx.lineWidth=1; ctx.strokeStyle='#0a0f20'; ctx.stroke();
    }
    const tt=data.tAxis[frame].toFixed(2);
    ctx.save();
    ctx.fillStyle='rgba(231,236,255,.8)';
    ctx.font='600 12px system-ui,-apple-system,Segoe UI,Roboto';
    ctx.fillText(`t = ${tt} s`, tf.pad+8, tf.pad+16);
    ctx.restore();
  }

  function drawTime(P, tf, colors, data, frame){
    const ctx=tctx;
    ctx.clearRect(0,0,tf.width, tf.height);
    drawAxes(ctx, tf, {xTicks:6,yTicks:6, xLabel:'Time (s)', yLabel:'V, W', showGrid:false});

    const M = Math.min(3, P.N);

    for(let i=0;i<M;i++){
      const color=colors[i];

      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle=color; ctx.lineWidth=1.6; ctx.globalAlpha=.95;
      for(let k=0;k<=frame;k++){
        const x=tf.toX(data.tAxis[k]);
        const y=tf.toY(data.V[k][i]);
        if(k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle=color;
      ctx.setLineDash([8,7]);
      ctx.lineWidth=1.6;
      ctx.globalAlpha=.6;
      for(let k=0;k<=frame;k++){
        const x=tf.toX(data.tAxis[k]);
        const y=tf.toY(data.W[k][i]);
        if(k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    const xcur=tf.toX(data.tAxis[frame]);
    ctx.save();
    ctx.strokeStyle='#7e8cc2';
    ctx.globalAlpha=.35;
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(xcur, tf.pad);
    ctx.lineTo(xcur, tf.height - tf.pad);
    ctx.stroke();
    ctx.restore();
  }

  let state={running:false, paused:false, frame:0, timer:null, P:{...DEFAULTS}, data:null, colors:null, tfPhase:null, tfTime:null};

  function getParams(){
    const P={
      N: clamp(parseInt($('N').value||DEFAULTS.N),1,2000),

      I: parseFloat($('I').value||DEFAULTS.I),
      gamma: parseFloat($('gamma').value||DEFAULTS.gamma),
      tau: Math.max(1e-9, parseFloat($('tau').value||DEFAULTS.tau)),
      d: Math.max(0, parseFloat($('d').value||DEFAULTS.d)),

      f: parseFloat($('f').value||DEFAULTS.f),
      e: parseFloat($('e').value||DEFAULTS.e),
      g: parseFloat($('g').value||DEFAULTS.g),

      alpha: parseFloat($('alpha').value||DEFAULTS.alpha),
      beta: Math.max(1e-9, parseFloat($('beta').value||DEFAULTS.beta)),

      a: parseFloat($('a').value||DEFAULTS.a),
      b: parseFloat($('b').value||DEFAULTS.b),
      c: parseFloat($('c').value||DEFAULTS.c),

      dt: Math.max(1e-6, parseFloat($('dt').value||DEFAULTS.dt)),
      steps: clamp(parseInt($('steps').value||DEFAULTS.steps),10,20000),

      fps: clamp(parseInt($('fps').value||DEFAULTS.fps),1,300),
      speed: clamp(parseInt($('speed').value||DEFAULTS.speed),1,200),

      trail: clamp(parseInt($('trail').value||DEFAULTS.trail),2,2000),
      seed: parseInt($('seed').value||DEFAULTS.seed),

      autoBounds: $('autoBounds').checked,
      vmin: parseFloat($('vmin').value||DEFAULTS.vmin),
      vmax: parseFloat($('vmax').value||DEFAULTS.vmax),
      wmin: parseFloat($('wmin').value||DEFAULTS.wmin),
      wmax: parseFloat($('wmax').value||DEFAULTS.wmax),
    };
    if(P.vmax < P.vmin){ const tmp=P.vmin; P.vmin=P.vmax; P.vmax=tmp; }
    if(P.wmax < P.wmin){ const tmp=P.wmin; P.wmin=P.wmax; P.wmax=tmp; }
    return P;
  }

  function start(){
    stop();
    state.P=getParams();
    resizeCanvases();

    let Psim = {...state.P};
    if(Psim.autoBounds){
      Psim.vmin = Math.min(Psim.vmin, -2.2);
      Psim.vmax = Math.max(Psim.vmax,  2.2);
      Psim.wmin = Math.min(Psim.wmin, -2.0);
      Psim.wmax = Math.max(Psim.wmax,  2.0);
    }
    state.data = simulate(Psim);

    if(state.P.autoBounds){
      const bounds = autoFitPhaseBounds(Psim, state.data);
      state.P.vmin = bounds.Vmin; state.P.vmax = bounds.Vmax;
      state.P.wmin = bounds.Wmin; state.P.wmax = bounds.Wmax;

      $('vmin').value = state.P.vmin.toFixed(3);
      $('vmax').value = state.P.vmax.toFixed(3);
      $('wmin').value = state.P.wmin.toFixed(3);
      $('wmax').value = state.P.wmax.toFixed(3);
    }

    const ps=cssSize(phaseCanvas), ts=cssSize(timeCanvas);
    state.tfPhase=makeTransform(state.P.vmin,state.P.vmax,state.P.wmin,state.P.wmax, ps.w, ps.h);
    state.tfTime=makeTransform(0, state.data.tAxis[state.P.steps-1], state.data.yMin,state.data.yMax, ts.w, ts.h);

    state.colors=makeColors(state.P.N);
    state.frame=0; state.paused=false; state.running=true;

    drawPhaseDynamic(state.P, state.tfPhase, state.colors, state.data, state.frame);
    drawTime(state.P, state.tfTime, state.colors, state.data, state.frame);

    const interval = Math.max(4, Math.round(1000/state.P.fps));
    state.timer=setInterval(()=>{
      if(state.paused) return;

      state.frame += state.P.speed;

      if(state.frame>=state.P.steps){
        state.frame = state.P.steps - 1;
        drawPhaseDynamic(state.P, state.tfPhase, state.colors, state.data, state.frame);
        drawTime(state.P, state.tfTime, state.colors, state.data, state.frame);
        stop();
        return;
      }

      drawPhaseDynamic(state.P, state.tfPhase, state.colors, state.data, state.frame);
      drawTime(state.P, state.tfTime, state.colors, state.data, state.frame);
    }, interval);

    $('pauseBtn').textContent='Pause';
  }

  function stop(){
    if(state.timer){ clearInterval(state.timer); state.timer=null; }
    state.running=false; state.paused=false;
  }

  function reset(){
    for(const [k,v] of Object.entries(DEFAULTS)){
      if($(k) && k !== "autoBounds") $(k).value=v;
    }
    $('autoBounds').checked = DEFAULTS.autoBounds;
    start();
  }

  $('runBtn').addEventListener('click', start);
  $('resetBtn').addEventListener('click', reset);
  $('pauseBtn').addEventListener('click', ()=>{
    if(!state.running){ start(); return; }
    state.paused=!state.paused;
    $('pauseBtn').textContent = state.paused ? 'Resume' : 'Pause';
  });

  window.addEventListener('resize', ()=>{
    if(!state.data) return;
    resizeCanvases();
    const ps=cssSize(phaseCanvas), ts=cssSize(timeCanvas);
    state.tfPhase=makeTransform(state.P.vmin,state.P.vmax,state.P.wmin,state.P.wmax, ps.w, ps.h);
    state.tfTime =makeTransform(0, state.data.tAxis[state.P.steps-1], state.data.yMin,state.data.yMax, ts.w, ts.h);
    drawPhaseDynamic(state.P, state.tfPhase, state.colors, state.data, state.frame);
    drawTime(state.P, state.tfTime, state.colors, state.data, state.frame);
  });

  document.getElementById('runBtn').textContent = 'Play';
  reset();
  </script>
</body>
</html>
